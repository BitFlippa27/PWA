{"ast":null,"code":"'use strict';\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\n\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({\n    obj: input\n  });\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n\n  while (next = queue.pop()) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({\n        val: ']'\n      });\n\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({\n          obj: obj[i],\n          prefix: arrayPrefix\n        });\n      }\n\n      queue.push({\n        val: '['\n      });\n    } else {\n      // object\n      keys = [];\n\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n\n      queue.push({\n        val: '}'\n      });\n\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = i > 0 ? ',' : '';\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({\n          obj: value,\n          prefix: objPrefix\n        });\n      }\n\n      queue.push({\n        val: '{'\n      });\n    }\n  }\n\n  return res;\n}; // Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\n\n\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) {\n    // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n\n  var i = 0;\n  var collationIndex, parsedNum, numChar;\n  var parsedString, lastCh, numConsecutiveSlashes, ch;\n  var arrayElement, objElement;\n\n  while (true) {\n    collationIndex = str[i++];\n\n    if (collationIndex === '}' || collationIndex === ']' || typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n\n      case 'n':\n        i += 3; // 'ull'\n\n        pop(null, stack, metaStack);\n        break;\n\n      case 't':\n        i += 3; // 'rue'\n\n        pop(true, stack, metaStack);\n        break;\n\n      case 'f':\n        i += 4; // 'alse'\n\n        pop(false, stack, metaStack);\n        break;\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n\n        while (true) {\n          numChar = str[i++];\n\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n\n        while (true) {\n          ch = str[i++];\n\n          if (ch !== '\"' || lastCh === '\\\\' && numConsecutiveSlashes % 2 === 1) {\n            parsedString += ch;\n            lastCh = ch;\n\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n\n      case '[':\n        arrayElement = {\n          element: [],\n          index: stack.length\n        };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n\n      case '{':\n        objElement = {\n          element: {},\n          index: stack.length\n        };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n\n      default:\n        throw new Error('unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};","map":{"version":3,"sources":["/home/x/Code/PWA/node_modules/vuvuzela/index.js"],"names":["exports","stringify","input","queue","push","obj","res","next","prefix","val","i","arrayPrefix","keys","k","key","value","objPrefix","pop","JSON","Array","isArray","length","hasOwnProperty","stack","metaStack","lastMetaElement","element","lastElementIndex","index","parse","str","collationIndex","parsedNum","numChar","parsedString","lastCh","numConsecutiveSlashes","ch","arrayElement","objElement","test","parseFloat","Error"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}